---
// Simplified scroll reveal component with better performance
---

<script>
  // Simplified scroll reveal with Intersection Observer
  document.addEventListener("DOMContentLoaded", function () {
    // Only initialize if user hasn't requested reduced motion
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      return;
    }

    const observerOptions = {
      threshold: 0.1,
      rootMargin: "0px 0px -50px 0px",
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add("revealed");
          observer.unobserve(entry.target); // Stop observing once revealed
        }
      });
    }, observerOptions);

    // Observe all elements with scroll-reveal class
    const scrollElements = document.querySelectorAll(".scroll-reveal");
    scrollElements.forEach((el) => observer.observe(el));

    // Immediately reveal elements that are already in viewport
    // This handles direct navigation with hash or initial page load
    function revealVisibleElements() {
      scrollElements.forEach((el) => {
        if (el.classList.contains("revealed")) return;

        const rect = el.getBoundingClientRect();
        const windowHeight =
          window.innerHeight || document.documentElement.clientHeight;
        // Check if element is in viewport (with same rootMargin as observer)
        if (rect.top < windowHeight - 50 && rect.bottom > 0) {
          el.classList.add("revealed");
          observer.unobserve(el);
        }
      });
    }

    // Run immediately to reveal elements already in viewport on initial load
    revealVisibleElements();

    // Run again after a short delay to handle hash navigation scenarios
    // where the browser scrolls to the target after DOMContentLoaded completes.
    // Use double requestAnimationFrame to ensure scroll has completed after hash navigation.
    requestAnimationFrame(() => {
      requestAnimationFrame(revealVisibleElements);
    });

    // Smooth scroll for anchor links
    const anchorLinks = document.querySelectorAll('a[href^="#"]');
    anchorLinks.forEach((link) => {
      link.addEventListener("click", function (e) {
        e.preventDefault();
        const anchor = e.currentTarget as HTMLAnchorElement;
        const href = anchor.getAttribute("href");
        const target = document.querySelector(href ?? "");
        if (target && target instanceof HTMLElement) {
          const headerOffset = 80;
          const elementPosition = target.offsetTop;
          const offsetPosition = elementPosition - headerOffset;

          window.scrollTo({
            top: offsetPosition,
            behavior: "smooth",
          });

          // Update URL without triggering scroll
          history.pushState(null, "", href ?? "");
        }
      });
    });

    // Add loading state removal for images
    const images = document.querySelectorAll("img");
    images.forEach((img) => {
      if (img.complete) {
        img.classList.add("loaded");
      } else {
        img.addEventListener("load", () => {
          img.classList.add("loaded");
        });
      }
    });
  });
</script>
